<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <!-- 视口设置：禁止缩放，适配刘海屏 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA 设置 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="我的播放器">
    <meta name="theme-color" content="#000000">
    <meta name="google" content="notranslate">
    
    <!-- 图标 -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='none' stroke='white' stroke-width='20' stroke-linejoin='round'/%3E%3C/svg%3E">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3C/svg%3E">

    <title>我的播放器</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.0/dist/hls.min.js"></script>

    <style>
        body { 
            background-color: black; margin: 0; padding: 0; 
            overflow: hidden; overscroll-behavior-y: none; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none; -webkit-user-select: none;
            position: fixed; width: 100%; height: 100%;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .ios-scroll {
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        video::-webkit-media-controls { display: none !important; }
        video::-webkit-media-controls-enclosure { display: none !important; }
        video::-webkit-media-controls-panel { display: none !important; }
        
        #root { height: 100dvh; width: 100vw; }

        @keyframes pulse-fast {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(0.95); }
        }
        .animate-pulse-fast {
            animation: pulse-fast 0.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: white;
            margin-top: -4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const HARDCODED_SOURCE_URL = "https://github.com/eilipufi/video/blob/main/vlist.txt";

        const Icon = ({ path, size = 28, className = "", onClick, style }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} onClick={onClick} style={{filter: 'drop-shadow(0px 1px 2px rgba(0,0,0,0.5))', ...style}}>{path}</svg>
        );

        const Icons = {
            Plus: (p) => <Icon {...p} path={<><path d="M12 5v14"/><path d="M5 12h14"/></>} />,
            Search: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></>} />,
            Play: (p) => <Icon {...p} path={<polygon points="5 3 19 12 5 21 5 3" fill="currentColor"/>} />,
            Forward: (p) => <Icon {...p} path={<><polygon points="13 19 22 12 13 5 13 19" fill="currentColor"/><polygon points="2 19 11 12 2 5 2 19" fill="currentColor"/></>} />,
            Rewind: (p) => <Icon {...p} path={<><polygon points="11 19 2 12 11 5 11 19" fill="currentColor"/><polygon points="22 19 13 12 22 5 22 19" fill="currentColor"/></>} />,
            Rotate: (p) => <Icon {...p} path={<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>} />,
            Maximize: (p) => <Icon {...p} path={<><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></>} />,
            Volume: (p) => <Icon {...p} path={<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>} />,
            VolumeX: (p) => <Icon {...p} path={<><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" x2="17" y1="9" y2="15"/><line x1="17" x2="23" y1="9" y2="15"/></>} />,
            Close: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></>} />
        };

        const parsePlaylist = (text) => {
            const lines = text.split('\n');
            const result = [];
            let currentTitle = null;
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                if (line.startsWith('#EXTINF:')) { currentTitle = line.split(',').pop().trim(); continue; }
                if (!line.startsWith('#') && line.includes(',') && line.includes('http')) {
                    const parts = line.split(',');
                    const urlPart = parts.find(p => p.trim().startsWith('http'));
                    if (urlPart) { result.push({ url: urlPart.trim(), name: parts.filter(p => p !== urlPart).join(',').trim() || currentTitle || "@频道" }); currentTitle = null; continue; }
                }
                if (line.startsWith('http')) { result.push({ url: line.trim(), name: currentTitle || "@频道" }); currentTitle = null; }
            }
            return result;
        };

        const formatTime = (time) => {
            if (!time || isNaN(time)) return "00:00";
            const m = Math.floor(time / 60);
            const s = Math.floor(time % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        };

        const INITIAL_VIDEOS = [
            { id: 1, url: "", username: "@初始化", description: "正在连接服务器...", avatar: "", likes: "" }
        ];

        const VideoSlide = ({ video, isActive, isMuted, toggleMute }) => {
            const videoRef = useRef(null);
            const hlsRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [rotation, setRotation] = useState(0);
            const [fit, setFit] = useState('contain');
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            
            const touchStartRef = useRef({ x: 0, y: 0, time: 0, startCurrentTime: 0 });
            const [isSeeking, setIsSeeking] = useState(false);
            const [seekTime, setSeekTime] = useState(0);

            // --- 核心修复：加载与自动播放逻辑 ---
            useEffect(() => {
                if (videoRef.current) {
                    videoRef.current.setAttribute('playsinline', 'true');
                    videoRef.current.setAttribute('webkit-playsinline', 'true');
                    videoRef.current.setAttribute('x5-playsinline', 'true');
                    videoRef.current.setAttribute('x5-video-player-type', 'h5-page');
                }

                if (!videoRef.current || !video.url) return;
                const src = video.url;
                
                // 辅助函数：安全播放
                const safePlay = () => {
                    if (isActive && videoRef.current) {
                        videoRef.current.play().catch(() => {});
                    }
                };

                if (Hls.isSupported() && src.includes('.m3u8')) {
                    if (hlsRef.current) hlsRef.current.destroy();
                    const hls = new Hls();
                    hls.loadSource(src);
                    hls.attachMedia(videoRef.current);
                    hls.on(Hls.Events.MANIFEST_PARSED, () => { 
                        if (isActive) safePlay();
                    });
                    hlsRef.current = hls;
                } else {
                    // Native HLS (iOS)
                    videoRef.current.src = src;
                    videoRef.current.load(); // 显式调用 load
                    // 监听元数据加载，确保加载完立即播放
                    videoRef.current.addEventListener('loadedmetadata', safePlay, { once: true });
                }
                
                setRotation(0);
                setFit('contain');
            }, [video.url]);

            // --- 切换激活状态时重置 ---
            useEffect(() => {
                if (isActive && video.url) {
                    if (videoRef.current) {
                        // 尝试播放，如果失败可能是因为数据还没加载，上面的 loadedmetadata 会补救
                        videoRef.current.play().catch(() => {});
                    }
                } else { 
                    if (videoRef.current) {
                        videoRef.current.pause(); 
                        try { videoRef.current.currentTime = 0; } catch(e){} // 只有安全时才重置
                    }
                    setIsPlaying(false);
                    setCurrentTime(0);
                }
            }, [isActive]);

            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchStartRef.current = { 
                    x: touch.clientX, 
                    y: touch.clientY, 
                    time: Date.now(),
                    startCurrentTime: videoRef.current ? videoRef.current.currentTime : 0
                };
            };

            const handleTouchMove = (e) => {
                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartRef.current.x;
                const deltaY = touch.clientY - touchStartRef.current.y;

                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
                    if (!isSeeking) setIsSeeking(true);
                    const seekDelta = deltaX / 5; 
                    const newTime = Math.max(0, Math.min(duration, touchStartRef.current.startCurrentTime + seekDelta));
                    setSeekTime(newTime);
                }
            };

            const handleTouchEnd = () => {
                if (isSeeking) {
                    if (videoRef.current) videoRef.current.currentTime = seekTime;
                    setIsSeeking(false);
                } else {
                    const holdTime = Date.now() - touchStartRef.current.time;
                    if (holdTime < 200) handleTap();
                }
            };

            const handleTap = () => {
                if (!video.url) return;
                if (isMuted) { toggleMute(); videoRef.current?.play(); } else { if (videoRef.current?.paused) videoRef.current.play(); else videoRef.current.pause(); }
            };

            const videoStyle = { width: '100%', height: '100%', objectFit: fit, transform: `rotate(${rotation}deg)`, transition: 'transform 0.3s ease', pointerEvents: 'none' };
            const displayTime = isSeeking ? seekTime : currentTime;

            return (
                <div className="relative w-full h-full snap-start bg-black flex-shrink-0 border-b border-gray-800 overflow-hidden">
                    <div className="video-wrapper relative w-full h-full">
                        <video 
                            ref={videoRef} style={videoStyle}
                            loop muted={isMuted}
                            playsInline={true} webkit-playsinline="true" x5-playsinline="true" x5-video-player-type="h5-page"
                            onTimeUpdate={(e) => { if (!isSeeking) { setCurrentTime(e.target.currentTime); setDuration(e.target.duration || 0); } }}
                            onPlay={() => setIsPlaying(true)} onPause={() => setIsPlaying(false)}
                        />
                        <div className="absolute inset-0 z-10" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd} onTouchMove={handleTouchMove} onTouchCancel={handleTouchEnd}></div>
                        
                        {isSeeking && (
                            <div className="absolute inset-0 flex items-center justify-center z-30 pointer-events-none bg-black/40 backdrop-blur-sm">
                                <div className="flex flex-col items-center">
                                    <div className="text-4xl font-bold text-white mb-2 font-mono drop-shadow-lg">
                                        {formatTime(seekTime)} 
                                        <span className="text-lg text-white/70 ml-2">/ {formatTime(duration)}</span>
                                    </div>
                                    <div className="text-white/80 text-sm font-bold">
                                        {seekTime > touchStartRef.current.startCurrentTime ? "⏩ 快进" : "⏪ 后退"}
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                    {!isPlaying && !isMuted && !isSeeking && video.url && <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20"><Icons.Play size={60} className="text-white/40" /></div>}

                    {/* 顶部进度条 */}
                    <div className="absolute top-0 left-0 right-0 z-50 px-4 pt-14 pb-6 bg-gradient-to-b from-black/90 to-transparent flex gap-3 items-center pointer-events-none">
                        <span className="text-[10px] text-white font-mono drop-shadow-md min-w-[30px] text-right">{formatTime(displayTime)}</span>
                        <div className="flex-1 h-1 bg-white/30 rounded-full overflow-hidden relative">
                            <div className="absolute top-0 left-0 h-full bg-white transition-all duration-100 box-shadow-lg" style={{width: `${(displayTime / (duration || 1)) * 100}%`}}></div>
                        </div>
                        <span className="text-[10px] text-white font-mono drop-shadow-md min-w-[30px]">{formatTime(duration)}</span>
                    </div>

                    {/* 右侧边栏 */}
                    <div className="absolute right-4 flex flex-col items-center gap-6 z-20" style={{bottom: '35%'}}>
                        <div onClick={() => setRotation(r => (r + 90) % 360)} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100"><div className="bg-black/30 p-2 rounded-full backdrop-blur-sm border border-white/10"><Icons.Rotate size={24} className="text-white" /></div><span className="text-[10px] text-white shadow-black drop-shadow-md">旋转</span></div>
                        <div onClick={() => setFit(f => f === 'contain' ? 'cover' : 'contain')} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100"><div className="bg-black/30 p-2 rounded-full backdrop-blur-sm border border-white/10"><Icons.Maximize size={24} className="text-white" /></div><span className="text-[10px] text-white shadow-black drop-shadow-md">缩放</span></div>
                        <div onClick={toggleMute} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100"><div className="bg-black/30 p-2 rounded-full backdrop-blur-sm border border-white/10">{isMuted ? <Icons.VolumeX size={24} className="text-white"/> : <Icons.Volume size={24} className="text-white"/>}</div><span className="text-[10px] text-white shadow-black drop-shadow-md">{isMuted ? '静音' : '音量'}</span></div>
                    </div>

                    <div className="absolute bottom-12 left-4 right-4 z-20 text-white pointer-events-none">
                        <div className="font-bold text-lg drop-shadow-md">{video.username}</div>
                        <div className="text-sm opacity-90 drop-shadow-md line-clamp-2 mt-1 leading-relaxed">{video.description}</div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [videos, setVideos] = useState(INITIAL_VIDEOS);
            const [activeId, setActiveId] = useState(INITIAL_VIDEOS[0].id);
            const [isMuted, setIsMuted] = useState(true);
            const [showModal, setShowModal] = useState(false);
            const containerRef = useRef(null);
            const [input, setInput] = useState('');
            const [proxy, setProxy] = useState(true);
            const [status, setStatus] = useState('');
            
            const allSourcesRef = useRef([]);

            const getRandomVideos = (count = 1) => {
                if (!allSourcesRef.current || allSourcesRef.current.length === 0) return [];
                const newItems = [];
                for (let i = 0; i < count; i++) {
                    const randomIndex = Math.floor(Math.random() * allSourcesRef.current.length);
                    const item = allSourcesRef.current[randomIndex];
                    newItems.push({
                        id: Date.now() + i + Math.random(),
                        url: item.url,
                        username: item.name,
                        description: `推荐视频 #${randomIndex + 1}`,
                        avatar: "" 
                    });
                }
                return newItems;
            };

            useEffect(() => {
                const autoFetch = async () => {
                    try {
                        let url = HARDCODED_SOURCE_URL;
                        let fetchUrl = url;
                        if (url.startsWith('http')) {
                            if (url.includes('github.com') && url.includes('/blob/')) { 
                                url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/'); 
                            }
                            fetchUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                        }
                        console.log("Loading list...");
                        const res = await fetch(fetchUrl);
                        if (!res.ok) throw new Error("加载列表失败");
                        const text = await res.text();
                        const items = parsePlaylist(text);
                        allSourcesRef.current = items;
                        if (items.length > 0) {
                            const initialBatch = getRandomVideos(3);
                            setVideos(initialBatch);
                        } else {
                            setVideos(prev => [{...prev[0], description: "列表为空"}]);
                        }
                    } catch (e) { 
                        setVideos(prev => [{...prev[0], description: "加载失败: " + e.message}]);
                    }
                };
                autoFetch();
            }, []);

            useEffect(() => {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(e => {
                        if (e.isIntersecting) {
                            const id = Number(e.target.getAttribute('data-id'));
                            setActiveId(id);
                            const currentIndex = videos.findIndex(v => v.id === id);
                            if (currentIndex >= videos.length - 2) {
                                const nextBatch = getRandomVideos(2);
                                setVideos(prev => [...prev, ...nextBatch]);
                            }
                        }
                    });
                }, { threshold: 0.6 });

                setTimeout(() => { document.querySelectorAll('.video-slide').forEach(el => observer.observe(el)); }, 500);
                return () => observer.disconnect();
            }, [videos]);

            const handleAdd = async () => {
                if (!input) return;
                try {
                    const items = parsePlaylist(input);
                    if (items.length > 0) {
                        allSourcesRef.current = items;
                        const initialBatch = getRandomVideos(3);
                        setVideos(initialBatch);
                        setShowModal(false); setInput('');
                    }
                } catch (e) { setStatus('错误: ' + e.message); }
            };

            return (
                <div className="flex justify-center bg-gray-900 h-screen w-full font-sans text-white">
                    <div className="relative w-full h-full bg-black overflow-hidden max-w-md mx-auto shadow-2xl">
                        <div className="absolute top-0 w-full p-4 pt-4 flex justify-between items-center z-30 bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
                            <Icons.Search className="text-white/80 pointer-events-auto opacity-0" />
                            <div className="flex gap-4 font-bold text-lg pointer-events-auto" style={{paddingTop: 'env(safe-area-inset-top)'}}>
                                <span className="opacity-60">关注</span><span className="border-b-2 border-white pb-1">推荐</span>
                            </div>
                            <button onClick={() => setShowModal(true)} className="pointer-events-auto" style={{paddingTop: 'env(safe-area-inset-top)'}}><Icons.Plus className="text-white" size={30} /></button>
                        </div>

                        <div ref={containerRef} className="w-full h-full overflow-y-scroll snap-y snap-mandatory scroll-smooth no-scrollbar ios-scroll">
                            {videos.map(v => (
                                <div key={v.id} data-id={v.id} className="video-slide w-full h-full snap-start relative">
                                    <VideoSlide video={v} isActive={activeId === v.id} isMuted={isMuted} toggleMute={() => setIsMuted(!isMuted)} />
                                </div>
                            ))}
                        </div>

                        {showModal && (
                            <div className="absolute inset-0 z-[100] bg-black/90 backdrop-blur-sm flex items-center justify-center p-6">
                                <div className="w-full bg-gray-900 border border-gray-700 rounded-2xl p-5 shadow-2xl">
                                    <div className="flex justify-between items-center mb-4"><h3 className="text-lg font-bold">添加视频源</h3><button onClick={() => setShowModal(false)}><Icons.Close size={24} className="text-gray-400"/></button></div>
                                    <textarea className="w-full bg-black text-white p-3 rounded-lg border border-gray-700 text-xs mb-3 focus:border-blue-500 outline-none" rows={5} placeholder="粘贴链接..." value={input} onChange={e => setInput(e.target.value)}></textarea>
                                    <label className="flex items-center gap-2 text-xs text-gray-400 mb-4"><input type="checkbox" checked={proxy} onChange={e => setProxy(e.target.checked)} className="rounded" /> 开启代理</label>
                                    <button onClick={handleAdd} className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 rounded-xl transition-colors">确定</button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
