<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <!-- 视口设置：使用 dvh 适配动态地址栏，禁止缩放 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA 设置：支持添加到主屏幕 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="我的播放器">
    <meta name="theme-color" content="#000000">
    <!-- 禁止 Chrome 自动翻译栏 -->
    <meta name="google" content="notranslate">
    
    <!-- 内置图标 (红色播放键) -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='none' stroke='white' stroke-width='20' stroke-linejoin='round'/%3E%3C/svg%3E">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3C/svg%3E">

    <title>我的播放器</title>
    
    <!-- 依赖库 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.0/dist/hls.min.js"></script>

    <style>
        /* 全局样式 */
        body { 
            background-color: black; margin: 0; padding: 0; 
            overflow: hidden; overscroll-behavior-y: none; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none; -webkit-user-select: none;
            /* 关键：防止 iOS Chrome 下拉刷新 */
            position: fixed; width: 100%; height: 100%;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .ios-scroll {
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        /* 隐藏原生控件 */
        video::-webkit-media-controls { display: none !important; }
        video::-webkit-media-controls-enclosure { display: none !important; }
        video::-webkit-media-controls-panel { display: none !important; }
        
        /* 100dvh 适配动态地址栏 */
        #root { height: 100dvh; width: 100vw; }

        @keyframes pulse-fast {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(0.95); }
        }
        .animate-pulse-fast {
            animation: pulse-fast 0.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // --- 仓库配置 ---
        const GITHUB_CONFIG = {
            username: 'eilipufi',
            repo: 'video',
            branch: 'main',
            filename: 'vlist.txt'
        };

        const Icon = ({ path, size = 28, className = "", onClick, style }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} onClick={onClick} style={{filter: 'drop-shadow(0px 1px 2px rgba(0,0,0,0.5))', ...style}}>{path}</svg>
        );

        const Icons = {
            Heart: (p) => <Icon {...p} path={<path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" fill={p.filled ? "#ef4444" : "none"} stroke={p.filled ? "none" : "currentColor"}/>} />,
            Plus: (p) => <Icon {...p} path={<><path d="M12 5v14"/><path d="M5 12h14"/></>} />,
            Search: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></>} />,
            Play: (p) => <Icon {...p} path={<polygon points="5 3 19 12 5 21 5 3" fill="currentColor"/>} />,
            Forward: (p) => <Icon {...p} path={<><polygon points="13 19 22 12 13 5 13 19" fill="currentColor"/><polygon points="2 19 11 12 2 5 2 19" fill="currentColor"/></>} />,
            Rewind: (p) => <Icon {...p} path={<><polygon points="11 19 2 12 11 5 11 19" fill="currentColor"/><polygon points="22 19 13 12 22 5 22 19" fill="currentColor"/></>} />,
            Rotate: (p) => <Icon {...p} path={<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>} />,
            Maximize: (p) => <Icon {...p} path={<><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></>} />,
            Volume: (p) => <Icon {...p} path={<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>} />,
            VolumeX: (p) => <Icon {...p} path={<><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" x2="17" y1="9" y2="15"/><line x1="17" x2="23" y1="9" y2="15"/></>} />,
            Close: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></>} />
        };

        const parsePlaylist = (text) => {
            const lines = text.split('\n');
            const result = [];
            let currentTitle = null;
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                if (line.startsWith('#EXTINF:')) { currentTitle = line.split(',').pop().trim(); continue; }
                if (!line.startsWith('#') && line.includes(',') && line.includes('http')) {
                    const parts = line.split(',');
                    const urlPart = parts.find(p => p.trim().startsWith('http'));
                    if (urlPart) { result.push({ url: urlPart.trim(), name: parts.filter(p => p !== urlPart).join(',').trim() || currentTitle || "@频道" }); currentTitle = null; continue; }
                }
                if (line.startsWith('http')) { result.push({ url: line.trim(), name: currentTitle || "@频道" }); currentTitle = null; }
            }
            return result;
        };

        const formatTime = (time) => {
            if (!time || isNaN(time)) return "00:00";
            const m = Math.floor(time / 60);
            const s = Math.floor(time % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        };

        const INITIAL_VIDEOS = [
            { 
                id: 1, 
                url: "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8", 
                username: "@系统消息", 
                description: "正在从 GitHub 加载视频源...", 
                avatar: "https://i.pravatar.cc/150?u=99",
                likes: "..."
            }
        ];

        const VideoSlide = ({ video, isActive, isMuted, toggleMute }) => {
            const videoRef = useRef(null);
            const hlsRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [rotation, setRotation] = useState(0);
            const [fit, setFit] = useState('contain');
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [isLiked, setIsLiked] = useState(false);
            
            const longPressTimerRef = useRef(null);
            const rewindIntervalRef = useRef(null);
            const touchStartRef = useRef({ x: 0, y: 0, time: 0 });
            const [pressAction, setPressAction] = useState(null); 

            useEffect(() => {
                if (videoRef.current) {
                    videoRef.current.setAttribute('playsinline', 'true');
                    videoRef.current.setAttribute('webkit-playsinline', 'true');
                    videoRef.current.setAttribute('x5-playsinline', 'true');
                    videoRef.current.setAttribute('x5-video-player-type', 'h5-page');
                }

                if (!videoRef.current || !video.url) return;
                const src = video.url;
                if (Hls.isSupported() && src.includes('.m3u8')) {
                    if (hlsRef.current) hlsRef.current.destroy();
                    const hls = new Hls();
                    hls.loadSource(src);
                    hls.attachMedia(videoRef.current);
                    hls.on(Hls.Events.MANIFEST_PARSED, () => { if (isActive) videoRef.current.play().catch(e => {}); });
                    hlsRef.current = hls;
                } else {
                    videoRef.current.src = src;
                }
                setRotation(0);
                setFit('contain');
                setPressAction(null);
            }, [video.url]);

            useEffect(() => {
                if (isActive && video.url) videoRef.current?.play().catch(e => {});
                else { 
                    videoRef.current?.pause(); 
                    setIsPlaying(false);
                    setPressAction(null);
                    if(rewindIntervalRef.current) clearInterval(rewindIntervalRef.current);
                }
            }, [isActive]);

            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                const width = e.currentTarget.clientWidth;
                const x = touch.clientX;
                const y = touch.clientY;
                
                touchStartRef.current = { x, y, time: Date.now() };
                const isRight = x > width / 2;

                longPressTimerRef.current = setTimeout(() => {
                    if (isRight) {
                        if (videoRef.current) videoRef.current.playbackRate = 2.0;
                        setPressAction('forward');
                    } else {
                        if (videoRef.current) {
                            videoRef.current.pause();
                            rewindIntervalRef.current = setInterval(() => {
                                videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 0.3);
                            }, 50);
                        }
                        setPressAction('rewind');
                    }
                }, 400); 
            };

            const handleTouchMove = (e) => {
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - touchStartRef.current.x);
                const deltaY = Math.abs(touch.clientY - touchStartRef.current.y);
                if (deltaX > 10 || deltaY > 10) { clearLongPress(); }
            };

            const handleTouchEnd = () => {
                clearLongPress();
                const holdTime = Date.now() - touchStartRef.current.time;
                if (!pressAction && holdTime < 400) { handleTap(); }
            };

            const clearLongPress = () => {
                if (longPressTimerRef.current) clearTimeout(longPressTimerRef.current);
                if (rewindIntervalRef.current) clearInterval(rewindIntervalRef.current);
                
                if (videoRef.current) {
                    videoRef.current.playbackRate = 1.0; 
                    if (pressAction === 'rewind') videoRef.current.play().catch(()=>{}); 
                }
                setPressAction(null);
            };

            const handleTap = () => {
                if (!video.url) return;
                if (isMuted) { toggleMute(); videoRef.current?.play(); } else { if (videoRef.current?.paused) videoRef.current.play(); else videoRef.current.pause(); }
            };

            const videoStyle = { width: '100%', height: '100%', objectFit: fit, transform: `rotate(${rotation}deg)`, transition: 'transform 0.3s ease', pointerEvents: 'none' };

            return (
                <div className="relative w-full h-full snap-start bg-black flex-shrink-0 border-b border-gray-800 overflow-hidden">
                    <div className="video-wrapper relative w-full h-full">
                        <video 
                            ref={videoRef} style={videoStyle}
                            loop muted={isMuted}
                            playsInline={true}
                            webkit-playsinline="true"
                            x5-playsinline="true"
                            x5-video-player-type="h5-page"
                            onTimeUpdate={(e) => { setCurrentTime(e.target.currentTime); setDuration(e.target.duration || 0); }}
                            onPlay={() => setIsPlaying(true)} onPause={() => setIsPlaying(false)}
                        />
                        <div className="absolute inset-0 z-10" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd} onTouchMove={handleTouchMove} onTouchCancel={handleTouchEnd}></div>
                        
                        {pressAction === 'forward' && (
                            <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none bg-black/20">
                                <div className="flex flex-col items-center bg-black/60 p-4 rounded-2xl backdrop-blur-md animate-pulse-fast">
                                    <Icons.Forward size={48} className="text-white" /><span className="text-white font-bold text-lg mt-2">2X 速</span>
                                </div>
                            </div>
                        )}
                        {pressAction === 'rewind' && (
                            <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none bg-black/20">
                                <div className="flex flex-col items-center bg-black/60 p-4 rounded-2xl backdrop-blur-md animate-pulse-fast">
                                    <Icons.Rewind size={48} className="text-white" /><span className="text-white font-bold text-lg mt-2">后退</span>
                                </div>
                            </div>
                        )}
                    </div>

                    {!isPlaying && !isMuted && !pressAction && video.url && <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20"><Icons.Play size={60} className="text-white/40" /></div>}

                    {/* 进度条 */}
                    <div className="absolute bottom-6 left-0 right-0 z-40 px-3 py-2 bg-gradient-to-t from-black/80 to-transparent flex gap-3 items-center">
                        <input type="range" min="0" max={duration || 100} value={currentTime} onChange={(e) => videoRef.current.currentTime = e.target.value} className="flex-1 h-1 bg-white/30 rounded-lg appearance-none outline-none z-50" style={{accentColor: 'white'}} />
                        <span className="text-[10px] text-white font-mono">{formatTime(currentTime)}</span>
                    </div>

                    {/* 侧边栏 */}
                    <div className="absolute bottom-28 right-2 flex flex-col items-center gap-5 z-20">
                        <div className="w-12 h-12 rounded-full border border-white/50 overflow-hidden bg-gray-700"><img src={video.avatar} className="w-full h-full object-cover"/></div>
                        <div onClick={() => setIsLiked(!isLiked)} className="flex flex-col items-center gap-1"><Icons.Heart size={32} filled={isLiked} className="text-white transition-all active:scale-125" /><span className="text-[10px] text-white shadow-black drop-shadow-md">{isLiked ? '1' : '0'}</span></div>
                        <div onClick={() => setRotation(r => (r + 90) % 360)} className="flex flex-col items-center gap-1"><Icons.Rotate size={28} className="text-white" /><span className="text-[10px] text-white shadow-black drop-shadow-md">旋转</span></div>
                        <div onClick={() => setFit(f => f === 'contain' ? 'cover' : 'contain')} className="flex flex-col items-center gap-1"><Icons.Maximize size={28} className="text-white" /><span className="text-[10px] text-white shadow-black drop-shadow-md">缩放</span></div>
                        <div onClick={toggleMute} className="flex flex-col items-center gap-1">{isMuted ? <Icons.VolumeX size={28} className="text-white"/> : <Icons.Volume size={28} className="text-white"/>}<span className="text-[10px] text-white shadow-black drop-shadow-md">{isMuted ? '静音' : '音量'}</span></div>
                    </div>

                    <div className="absolute bottom-16 left-4 right-16 z-20 text-white pointer-events-none">
                        <div className="font-bold text-lg drop-shadow-md">{video.username}</div>
                        <div className="text-sm opacity-90 drop-shadow-md line-clamp-2">{video.description}</div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [videos, setVideos] = useState(INITIAL_VIDEOS);
            const [activeId, setActiveId] = useState(INITIAL_VIDEOS[0].id);
            const [isMuted, setIsMuted] = useState(true);
            const [showModal, setShowModal] = useState(false);
            const containerRef = useRef(null);
            const [input, setInput] = useState('');
            const [proxy, setProxy] = useState(true);
            const [status, setStatus] = useState('');

            useEffect(() => {
                const autoFetch = async () => {
                    try {
                        const loadVideos = (items, sourceName) => {
                            const newVideos = items.map((it, idx) => ({
                                id: Date.now() + idx + Math.random(),
                                url: it.url, username: it.name, description: `来源: ${sourceName}`, avatar: `https://i.pravatar.cc/150?u=${idx + 10}`
                            }));
                            setVideos(newVideos);
                            setStatus('');
                        };

                        // 1. 尝试直接加载 (相对路径)
                        try {
                            const res = await fetch(GITHUB_CONFIG.filename);
                            if (res.ok) {
                                const text = await res.text();
                                const items = parsePlaylist(text);
                                if (items.length > 0) {
                                    loadVideos(items, "本地源");
                                    return; // 成功，退出
                                }
                            }
                        } catch (e) {
                            console.log("Relative fetch failed, trying remote...", e);
                        }

                        // 2. 失败则尝试远程加载 (走代理)
                        const rawUrl = `https://raw.githubusercontent.com/${GITHUB_CONFIG.username}/${GITHUB_CONFIG.repo}/${GITHUB_CONFIG.branch}/${GITHUB_CONFIG.filename}`;
                        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(rawUrl)}`;
                        
                        const resRemote = await fetch(proxyUrl);
                        if (!resRemote.ok) throw new Error("远程加载失败");
                        
                        const textRemote = await resRemote.text();
                        const itemsRemote = parsePlaylist(textRemote);
                        
                        if (itemsRemote.length > 0) {
                            loadVideos(itemsRemote, "远程源");
                        } else {
                            throw new Error("源文件为空");
                        }

                    } catch (e) {
                        console.error(e);
                        setVideos(prev => [{...prev[0], description: `加载失败: ${e.message}. 请检查 GitHub 文件是否公开。`}]);
                    }
                };
                autoFetch();
            }, []);

            useEffect(() => {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(e => { if (e.isIntersecting) setActiveId(Number(e.target.getAttribute('data-id'))); });
                }, { threshold: 0.6 });
                setTimeout(() => { document.querySelectorAll('.video-slide').forEach(el => observer.observe(el)); }, 500);
                return () => observer.disconnect();
            }, [videos]);

            const handleAdd = async () => {
                if (!input) return;
                setStatus('正在读取...');
                try {
                    let items = [];
                    let url = input.trim();
                    let fetchUrl = url;

                    if (url.startsWith('http')) {
                        if (url.includes('github.com') && url.includes('/blob/')) { 
                            url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/'); 
                        }
                        if (proxy) fetchUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                    }
                    
                    const res = await fetch(fetchUrl);
                    if (!res.ok) throw new Error("失败");
                    const text = await res.text();
                    items = parsePlaylist(text);
                    
                    if (items.length > 0) {
                        setVideos(prev => {
                            const exists = new Set(prev.map(v => v.url));
                            const news = items.filter(i => !exists.has(i.url)).map((it, idx) => ({
                                id: Date.now() + idx + Math.random(), url: it.url, username: it.name, description: '手动导入', avatar: `https://i.pravatar.cc/150?u=${idx + 999}`
                            }));
                            return [...news, ...prev];
                        });
                        setShowModal(false); setStatus(''); setInput('');
                    } else setStatus('无效内容');
                } catch (e) { setStatus('错误: ' + e.message); }
            };

            return (
                <div className="flex justify-center bg-gray-900 h-screen w-full font-sans text-white">
                    <div className="relative w-full h-full bg-black overflow-hidden max-w-md mx-auto shadow-2xl">
                        <div className="absolute top-0 w-full p-4 pt-12 flex justify-between items-center z-30 bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
                            <Icons.Search className="text-white/80 pointer-events-auto" />
                            <div className="flex gap-4 font-bold text-lg"><span className="opacity-60">关注</span><span className="border-b-2 border-white pb-1">推荐</span></div>
                            <button onClick={() => setShowModal(true)} className="pointer-events-auto"><Icons.Plus className="text-white" size={30} /></button>
                        </div>

                        <div ref={containerRef} className="w-full h-full overflow-y-scroll snap-y snap-mandatory scroll-smooth no-scrollbar ios-scroll">
                            {videos.map(v => (
                                <div key={v.id} data-id={v.id} className="video-slide w-full h-full snap-start relative">
                                    <VideoSlide video={v} isActive={activeId === v.id} isMuted={isMuted} toggleMute={() => setIsMuted(!isMuted)} />
                                </div>
                            ))}
                        </div>

                        {showModal && (
                            <div className="absolute inset-0 z-[100] bg-black/90 backdrop-blur-sm flex items-center justify-center p-6">
                                <div className="w-full bg-gray-900 border border-gray-700 rounded-2xl p-5 shadow-2xl">
                                    <div className="flex justify-between items-center mb-4"><h3 className="text-lg font-bold">添加视频源</h3><button onClick={() => setShowModal(false)}><Icons.Close size={24} className="text-gray-400"/></button></div>
                                    <textarea className="w-full bg-black text-white p-3 rounded-lg border border-gray-700 text-xs mb-3 focus:border-blue-500 outline-none" rows={5} placeholder="粘贴链接..." value={input} onChange={e => setInput(e.target.value)}></textarea>
                                    <label className="flex items-center gap-2 text-xs text-gray-400 mb-4"><input type="checkbox" checked={proxy} onChange={e => setProxy(e.target.checked)} className="rounded" /> 开启代理</label>
                                    {status && <div className="text-blue-400 text-xs mb-3 p-2 bg-blue-900/30 rounded">{status}</div>}
                                    <button onClick={handleAdd} className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 rounded-xl transition-colors">确定</button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
