<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <!-- 视口设置：禁止缩放，适配刘海屏 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA 设置 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="我的播放器">
    <meta name="theme-color" content="#000000">
    <meta name="google" content="notranslate">
    
    <!-- 图标 -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='none' stroke='white' stroke-width='20' stroke-linejoin='round'/%3E%3C/svg%3E">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3C/svg%3E">

    <title>我的播放器</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.0/dist/hls.min.js"></script>

    <style>
        body { 
            background-color: black; margin: 0; padding: 0; 
            overflow: hidden; overscroll-behavior-y: none; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none; -webkit-user-select: none;
            position: fixed; width: 100%; height: 100%;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .ios-scroll {
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        video::-webkit-media-controls { display: none !important; }
        video::-webkit-media-controls-enclosure { display: none !important; }
        video::-webkit-media-controls-panel { display: none !important; }
        
        /* 100dvh 适配 */
        #root { height: 100dvh; width: 100vw; }

        @keyframes pulse-fast {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(0.95); }
        }
        .animate-pulse-fast {
            animation: pulse-fast 0.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        /* 进度条样式优化 */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: white;
            margin-top: -4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        // 使用相对路径，优先加载 vlist.txt，无需代理
        const HARDCODED_SOURCE_URL = "vlist.txt";

        const Icon = ({ path, size = 28, className = "", onClick, style }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} onClick={onClick} style={{filter: 'drop-shadow(0px 1px 2px rgba(0,0,0,0.5))', ...style}}>{path}</svg>
        );

        const Icons = {
            Plus: (p) => <Icon {...p} path={<><path d="M12 5v14"/><path d="M5 12h14"/></>} />,
            Search: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></>} />,
            Play: (p) => <Icon {...p} path={<polygon points="5 3 19 12 5 21 5 3" fill="currentColor"/>} />,
            Rotate: (p) => <Icon {...p} path={<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>} />,
            Maximize: (p) => <Icon {...p} path={<><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></>} />,
            Volume: (p) => <Icon {...p} path={<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>} />,
            VolumeX: (p) => <Icon {...p} path={<><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" x2="17" y1="9" y2="15"/><line x1="17" x2="23" y1="9" y2="15"/></>} />,
            Close: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></>} />,
            FastForward: (p) => <Icon {...p} path={<><polygon points="13 19 22 12 13 5 13 19" fill="currentColor"/><polygon points="2 19 11 12 2 5 2 19" fill="currentColor"/></>} />,
            Rewind: (p) => <Icon {...p} path={<><polygon points="11 19 2 12 11 5 11 19" fill="currentColor"/><polygon points="22 19 13 12 22 5 22 19" fill="currentColor"/></>} />
        };

        const parsePlaylist = (text) => {
            const lines = text.split('\n');
            const result = [];
            let currentTitle = null;
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                if (line.startsWith('#EXTINF:')) { currentTitle = line.split(',').pop().trim(); continue; }
                if (!line.startsWith('#') && line.includes(',') && line.includes('http')) {
                    const parts = line.split(',');
                    const urlPart = parts.find(p => p.trim().startsWith('http'));
                    if (urlPart) { result.push({ url: urlPart.trim(), name: parts.filter(p => p !== urlPart).join(',').trim() || currentTitle || "@频道" }); currentTitle = null; continue; }
                }
                if (line.startsWith('http')) { result.push({ url: line.trim(), name: currentTitle || "@频道" }); currentTitle = null; }
            }
            return result;
        };

        const formatTime = (time) => {
            if (!time || isNaN(time)) return "00:00";
            const m = Math.floor(time / 60);
            const s = Math.floor(time % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        };

        const INITIAL_VIDEOS = [
            { 
                id: 1, 
                url: "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8", 
                username: "@系统消息", 
                description: "正在加载...", 
                avatar: "https://i.pravatar.cc/150?u=99",
                likes: "..."
            }
        ];

        const VideoSlide = ({ video, isActive, isMuted, toggleMute }) => {
            const videoRef = useRef(null);
            const hlsRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [rotation, setRotation] = useState(0);
            const [fit, setFit] = useState('contain');
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            
            // --- 手势与进度控制状态 ---
            const touchStartRef = useRef({ x: 0, y: 0, time: 0, startCurrentTime: 0 });
            const [isSeeking, setIsSeeking] = useState(false);
            const [seekTime, setSeekTime] = useState(0);

            useEffect(() => {
                if (videoRef.current) {
                    videoRef.current.setAttribute('playsinline', 'true');
                    videoRef.current.setAttribute('webkit-playsinline', 'true');
                    videoRef.current.setAttribute('x5-playsinline', 'true');
                    videoRef.current.setAttribute('x5-video-player-type', 'h5-page');
                }

                if (!videoRef.current || !video.url) return;
                const src = video.url;
                if (Hls.isSupported() && src.includes('.m3u8')) {
                    if (hlsRef.current) hlsRef.current.destroy();
                    const hls = new Hls();
                    hls.loadSource(src);
                    hls.attachMedia(videoRef.current);
                    hls.on(Hls.Events.MANIFEST_PARSED, () => { if (isActive) videoRef.current.play().catch(e => {}); });
                    hlsRef.current = hls;
                } else {
                    videoRef.current.src = src;
                }
                setRotation(0);
                setFit('contain');
            }, [video.url]);

            useEffect(() => {
                if (isActive && video.url) videoRef.current?.play().catch(e => {});
                else { 
                    videoRef.current?.pause(); 
                    setIsPlaying(false);
                }
            }, [isActive]);

            // --- 核心：左右滑动调节进度逻辑 ---
            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchStartRef.current = { 
                    x: touch.clientX, 
                    y: touch.clientY, 
                    time: Date.now(),
                    startCurrentTime: videoRef.current ? videoRef.current.currentTime : 0
                };
                // 不在这里设置 seeking，防止误触点击
            };

            const handleTouchMove = (e) => {
                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartRef.current.x;
                const deltaY = touch.clientY - touchStartRef.current.y;

                // 如果横向移动明显大于纵向移动，且移动距离超过 20px，判定为拖动进度
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
                    if (!isSeeking) setIsSeeking(true);
                    
                    // 计算新时间：每 5px 移动 1 秒 (可调整灵敏度)
                    const seekDelta = deltaX / 5; 
                    const newTime = Math.max(0, Math.min(duration, touchStartRef.current.startCurrentTime + seekDelta));
                    setSeekTime(newTime);
                }
            };

            const handleTouchEnd = () => {
                if (isSeeking) {
                    // 应用拖动后的时间
                    if (videoRef.current) {
                        videoRef.current.currentTime = seekTime;
                    }
                    setIsSeeking(false);
                } else {
                    // 如果不是 seeking，且时间极短，视为点击播放/暂停
                    const holdTime = Date.now() - touchStartRef.current.time;
                    if (holdTime < 200) {
                        handleTap();
                    }
                }
            };

            const handleTap = () => {
                if (!video.url) return;
                if (isMuted) { toggleMute(); videoRef.current?.play(); } else { if (videoRef.current?.paused) videoRef.current.play(); else videoRef.current.pause(); }
            };

            const videoStyle = { width: '100%', height: '100%', objectFit: fit, transform: `rotate(${rotation}deg)`, transition: 'transform 0.3s ease', pointerEvents: 'none' };

            // 格式化当前显示时间 (正常播放或拖动时)
            const displayTime = isSeeking ? seekTime : currentTime;

            return (
                <div className="relative w-full h-full snap-start bg-black flex-shrink-0 border-b border-gray-800 overflow-hidden">
                    <div className="video-wrapper relative w-full h-full">
                        <video 
                            ref={videoRef} style={videoStyle}
                            loop muted={isMuted}
                            playsInline={true}
                            webkit-playsinline="true"
                            x5-playsinline="true"
                            x5-video-player-type="h5-page"
                            onTimeUpdate={(e) => { 
                                if (!isSeeking) {
                                    setCurrentTime(e.target.currentTime); 
                                    setDuration(e.target.duration || 0); 
                                }
                            }}
                            onPlay={() => setIsPlaying(true)} onPause={() => setIsPlaying(false)}
                        />
                        {/* 交互层 */}
                        <div className="absolute inset-0 z-10" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd} onTouchMove={handleTouchMove} onTouchCancel={handleTouchEnd}></div>
                        
                        {/* --- 拖动进度的中央提示 --- */}
                        {isSeeking && (
                            <div className="absolute inset-0 flex items-center justify-center z-30 pointer-events-none bg-black/40 backdrop-blur-sm">
                                <div className="flex flex-col items-center">
                                    <div className="text-4xl font-bold text-white mb-2 font-mono">
                                        {formatTime(seekTime)} 
                                        <span className="text-lg text-white/70 ml-2">/ {formatTime(duration)}</span>
                                    </div>
                                    <div className="text-white/80 text-sm">
                                        {seekTime > touchStartRef.current.startCurrentTime ? "快进 >>" : "<< 后退"}
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                    {!isPlaying && !isMuted && !isSeeking && video.url && <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20"><Icons.Play size={60} className="text-white/40" /></div>}

                    {/* --- 顶部进度条 (位于屏幕最上方) --- */}
                    {/* 使用 padding-top 避开 safe-area 和浏览器边框，增加 z-index 防止被遮挡 */}
                    <div className="absolute top-0 left-0 right-0 z-50 px-4 pt-16 pb-4 bg-gradient-to-b from-black/80 to-transparent flex gap-3 items-center pointer-events-none">
                        <span className="text-[10px] text-white font-mono drop-shadow-md">{formatTime(displayTime)}</span>
                        {/* 进度条轨道 */}
                        <div className="flex-1 h-1 bg-white/30 rounded-full overflow-hidden relative">
                            {/* 播放进度 */}
                            <div className="absolute top-0 left-0 h-full bg-white transition-all duration-100" style={{width: `${(displayTime / (duration || 1)) * 100}%`}}></div>
                        </div>
                        <span className="text-[10px] text-white font-mono drop-shadow-md">{formatTime(duration)}</span>
                    </div>

                    {/* --- 右侧边栏 (精简版：仅保留功能键，大幅上移) --- */}
                    {/* 使用 bottom: 40% 确保在任何屏幕中间偏下位置 */}
                    <div className="absolute right-4 flex flex-col items-center gap-6 z-20" style={{bottom: '40%'}}>
                        <div onClick={() => setRotation(r => (r + 90) % 360)} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100">
                            <div className="bg-black/30 p-2 rounded-full backdrop-blur-sm"><Icons.Rotate size={24} className="text-white" /></div>
                            <span className="text-[10px] text-white shadow-black drop-shadow-md">旋转</span>
                        </div>
                        <div onClick={() => setFit(f => f === 'contain' ? 'cover' : 'contain')} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100">
                            <div className="bg-black/30 p-2 rounded-full backdrop-blur-sm"><Icons.Maximize size={24} className="text-white" /></div>
                            <span className="text-[10px] text-white shadow-black drop-shadow-md">缩放</span>
                        </div>
                        <div onClick={toggleMute} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100">
                            <div className="bg-black/30 p-2 rounded-full backdrop-blur-sm">{isMuted ? <Icons.VolumeX size={24} className="text-white"/> : <Icons.Volume size={24} className="text-white"/>}</div>
                            <span className="text-[10px] text-white shadow-black drop-shadow-md">{isMuted ? '静音' : '音量'}</span>
                        </div>
                    </div>

                    {/* --- 底部信息 (也相应上移，留出底部手势空间) --- */}
                    <div className="absolute bottom-16 left-4 right-4 z-20 text-white pointer-events-none">
                        <div className="font-bold text-lg drop-shadow-md">{video.username}</div>
                        <div className="text-sm opacity-90 drop-shadow-md line-clamp-2 mt-1">{video.description}</div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [videos, setVideos] = useState(INITIAL_VIDEOS);
            const [activeId, setActiveId] = useState(INITIAL_VIDEOS[0].id);
            const [isMuted, setIsMuted] = useState(true);
            const [showModal, setShowModal] = useState(false);
            const containerRef = useRef(null);
            const [input, setInput] = useState('');
            const [proxy, setProxy] = useState(true);
            const [status, setStatus] = useState('');

            useEffect(() => {
                const autoFetch = async () => {
                    try {
                        let url = HARDCODED_SOURCE_URL;
                        let fetchUrl = url;

                        if (url.startsWith('http')) {
                            if (url.includes('github.com') && url.includes('/blob/')) { 
                                url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/'); 
                            }
                            fetchUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                        }

                        console.log("Loading source:", fetchUrl);
                        const res = await fetch(fetchUrl);
                        
                        if (!res.ok) throw new Error(`Network error: ${res.status}`);
                        const text = await res.text();
                        const items = parsePlaylist(text);
                        
                        if (items.length > 0) {
                            const newVideos = items.map((it, idx) => ({
                                id: Date.now() + idx + Math.random(),
                                url: it.url, username: it.name, description: '自动加载', avatar: `https://i.pravatar.cc/150?u=${idx + 10}`
                            }));
                            setVideos(newVideos); 
                        } else {
                            setVideos(prev => [{...prev[0], description: "源文件为空或格式错误"}]);
                        }
                    } catch (e) { 
                        console.log("Auto load failed", e); 
                        setVideos(prev => [{...prev[0], description: "加载失败: " + e.message}]);
                    }
                };
                autoFetch();
            }, []);

            useEffect(() => {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(e => { if (e.isIntersecting) setActiveId(Number(e.target.getAttribute('data-id'))); });
                }, { threshold: 0.6 });
                setTimeout(() => { document.querySelectorAll('.video-slide').forEach(el => observer.observe(el)); }, 500);
                return () => observer.disconnect();
            }, [videos]);

            const handleAdd = async () => {
                if (!input) return;
                setStatus('正在读取...');
                try {
                    let items = [];
                    let url = input.trim();
                    let fetchUrl = url;

                    if (url.startsWith('http')) {
                        if (url.includes('github.com') && url.includes('/blob/')) { 
                            url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/'); 
                        }
                        if (proxy) fetchUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                    }
                    
                    const res = await fetch(fetchUrl);
                    if (!res.ok) throw new Error("失败");
                    const text = await res.text();
                    items = parsePlaylist(text);
                    
                    if (items.length > 0) {
                        setVideos(prev => {
                            const exists = new Set(prev.map(v => v.url));
                            const news = items.filter(i => !exists.has(i.url)).map((it, idx) => ({
                                id: Date.now() + idx + Math.random(), url: it.url, username: it.name, description: '手动导入', avatar: `https://i.pravatar.cc/150?u=${idx + 999}`
                            }));
                            return [...news, ...prev];
                        });
                        setShowModal(false); setStatus(''); setInput('');
                    } else setStatus('无效内容');
                } catch (e) { setStatus('错误: ' + e.message); }
            };

            return (
                <div className="flex justify-center bg-gray-900 h-screen w-full font-sans text-white">
                    <div className="relative w-full h-full bg-black overflow-hidden max-w-md mx-auto shadow-2xl">
                        <div className="absolute top-0 w-full p-4 pt-4 flex justify-between items-center z-30 bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
                            <Icons.Search className="text-white/80 pointer-events-auto opacity-0" /> {/* 占位保持布局，隐藏搜索 */}
                            <div className="flex gap-4 font-bold text-lg pointer-events-auto" style={{paddingTop: 'env(safe-area-inset-top)'}}>
                                <span className="opacity-60">关注</span>
                                <span className="border-b-2 border-white pb-1">推荐</span>
                            </div>
                            <button onClick={() => setShowModal(true)} className="pointer-events-auto" style={{paddingTop: 'env(safe-area-inset-top)'}}><Icons.Plus className="text-white" size={30} /></button>
                        </div>

                        <div ref={containerRef} className="w-full h-full overflow-y-scroll snap-y snap-mandatory scroll-smooth no-scrollbar ios-scroll">
                            {videos.map(v => (
                                <div key={v.id} data-id={v.id} className="video-slide w-full h-full snap-start relative">
                                    <VideoSlide video={v} isActive={activeId === v.id} isMuted={isMuted} toggleMute={() => setIsMuted(!isMuted)} />
                                </div>
                            ))}
                        </div>

                        {showModal && (
                            <div className="absolute inset-0 z-[100] bg-black/90 backdrop-blur-sm flex items-center justify-center p-6">
                                <div className="w-full bg-gray-900 border border-gray-700 rounded-2xl p-5 shadow-2xl">
                                    <div className="flex justify-between items-center mb-4"><h3 className="text-lg font-bold">添加视频源</h3><button onClick={() => setShowModal(false)}><Icons.Close size={24} className="text-gray-400"/></button></div>
                                    <textarea className="w-full bg-black text-white p-3 rounded-lg border border-gray-700 text-xs mb-3 focus:border-blue-500 outline-none" rows={5} placeholder="粘贴链接..." value={input} onChange={e => setInput(e.target.value)}></textarea>
                                    <label className="flex items-center gap-2 text-xs text-gray-400 mb-4"><input type="checkbox" checked={proxy} onChange={e => setProxy(e.target.checked)} className="rounded" /> 开启代理</label>
                                    {status && <div className="text-blue-400 text-xs mb-3 p-2 bg-blue-900/30 rounded">{status}</div>}
                                    <button onClick={handleAdd} className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 rounded-xl transition-colors">确定</button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
