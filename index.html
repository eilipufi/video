<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA 设置 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="我的播放器">
    <meta name="theme-color" content="#000000">
    <meta name="google" content="notranslate">
    
    <!-- 图标 -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='none' stroke='white' stroke-width='20' stroke-linejoin='round'/%3E%3C/svg%3E">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' ry='100' fill='%23000000'/%3E%3Cpath d='M180 140 L380 256 L180 372 Z' fill='%23ff0050'/%3E%3C/svg%3E">

    <title>我的播放器</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.0/dist/hls.min.js"></script>

    <style>
        body { 
            background-color: black; margin: 0; padding: 0; 
            overflow: hidden; overscroll-behavior-y: none; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none; -webkit-user-select: none;
            position: fixed; width: 100%; height: 100%;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .ios-scroll {
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        video::-webkit-media-controls { display: none !important; }
        video::-webkit-media-controls-enclosure { display: none !important; }
        video::-webkit-media-controls-panel { display: none !important; }
        
        #root { height: 100dvh; width: 100vw; }

        @keyframes pulse-fast {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(0.95); }
        }
        .animate-pulse-fast {
            animation: pulse-fast 0.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // ==========================================
        //  硬编码数据源 (已替换为你提供的20条)
        // ==========================================
        const ALL_SOURCES = [
            "https://t27.cdn2020.com/video/m3u8/2022/11/19/a367abe8/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/17/5e8d4660/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/17/b4dce4e5/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/17/ddab062a/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/17/7c4f4d2d/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/17/3b15ec39/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/17/f93873e3/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/11/b10e775c/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/11/8175099f/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/11/f7ae0496/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/11/a23a1cda/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/498f2974/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/41981bb3/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/59944cac/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/7f10a096/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/5e83ed8e/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/8bafbcae/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/4ed7a7c1/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/5393ce0b/index.m3u8",
            "https://t27.cdn2020.com/video/m3u8/2022/11/15/6cfa00d3/index.m3u8"
        ];

        // 虚拟化配置：解决大量数据卡顿问题
        // 只渲染当前视频的前后 1 个 (总共保持 3 个活跃 DOM)
        const RENDER_WINDOW = 1; 
        // 初始加载数量
        const INITIAL_LOAD_COUNT = 5;
        // 每次追加数量
        const BATCH_SIZE = 5;

        const Icon = ({ path, size = 28, className = "", onClick, style }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} onClick={onClick} style={{filter: 'drop-shadow(0px 1px 2px rgba(0,0,0,0.5))', ...style}}>{path}</svg>
        );

        const Icons = {
            Rotate: (p) => <Icon {...p} path={<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>} />,
            Maximize: (p) => <Icon {...p} path={<><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></>} />,
            Volume: (p) => <Icon {...p} path={<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>} />,
            VolumeX: (p) => <Icon {...p} path={<><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" x2="17" y1="9" y2="15"/><line x1="17" x2="23" y1="9" y2="15"/></>} />,
            Play: (p) => <Icon {...p} path={<polygon points="5 3 19 12 5 21 5 3" fill="currentColor"/>} />,
            Forward: (p) => <Icon {...p} path={<><polygon points="13 19 22 12 13 5 13 19" fill="currentColor"/><polygon points="2 19 11 12 2 5 2 19" fill="currentColor"/></>} />,
            Rewind: (p) => <Icon {...p} path={<><polygon points="11 19 2 12 11 5 11 19" fill="currentColor"/><polygon points="22 19 13 12 22 5 22 19" fill="currentColor"/></>} />
        };

        const formatTime = (time) => {
            if (!time || isNaN(time)) return "00:00";
            const m = Math.floor(time / 60);
            const s = Math.floor(time % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        };

        const VideoSlide = ({ video, isActive, isVisible, isMuted, toggleMute }) => {
            // 虚拟化核心：不可见的视频只渲染占位符，内存占用极低
            if (!isVisible) {
                return (
                    <div className="relative w-full h-full snap-start bg-black flex-shrink-0 border-b border-gray-800 flex items-center justify-center">
                        <div className="text-gray-800 text-xs">Waiting...</div>
                    </div>
                );
            }

            const videoRef = useRef(null);
            const hlsRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [rotation, setRotation] = useState(0);
            const [fit, setFit] = useState('contain');
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            
            const touchStartRef = useRef({ x: 0, y: 0, time: 0, startCurrentTime: 0 });
            const [isSeeking, setIsSeeking] = useState(false);
            const [seekTime, setSeekTime] = useState(0);

            useEffect(() => {
                if (videoRef.current) {
                    videoRef.current.setAttribute('playsinline', 'true');
                    videoRef.current.setAttribute('webkit-playsinline', 'true');
                    videoRef.current.setAttribute('x5-playsinline', 'true');
                    videoRef.current.setAttribute('x5-video-player-type', 'h5-page');
                }

                if (!videoRef.current || !video.url) return;
                const src = video.url;
                
                const safePlay = () => {
                    if (isActive && videoRef.current) {
                        videoRef.current.play().catch(() => {});
                    }
                };

                if (Hls.isSupported() && src.includes('.m3u8')) {
                    if (hlsRef.current) hlsRef.current.destroy();
                    const hls = new Hls({ maxBufferLength: 30, maxMaxBufferLength: 60 });
                    hls.loadSource(src);
                    hls.attachMedia(videoRef.current);
                    hls.on(Hls.Events.MANIFEST_PARSED, () => { if (isActive) safePlay(); });
                    hlsRef.current = hls;
                } else {
                    videoRef.current.src = src;
                    videoRef.current.load();
                    videoRef.current.addEventListener('loadedmetadata', safePlay, { once: true });
                }
                
                setRotation(0);
                setFit('contain');

                return () => { if (hlsRef.current) { hlsRef.current.destroy(); hlsRef.current = null; } }
            }, [video.url]);

            // 切换视频时重置
            useEffect(() => {
                if (isActive && video.url) {
                    if (videoRef.current) {
                        videoRef.current.currentTime = 0; 
                        videoRef.current.play().catch(e => {});
                    }
                } else { 
                    if (videoRef.current) {
                        videoRef.current.pause(); 
                        videoRef.current.currentTime = 0; 
                    }
                    setIsPlaying(false);
                    setCurrentTime(0);
                }
            }, [isActive]);

            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchStartRef.current = { 
                    x: touch.clientX, y: touch.clientY, time: Date.now(),
                    startCurrentTime: videoRef.current ? videoRef.current.currentTime : 0
                };
            };

            const handleTouchMove = (e) => {
                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartRef.current.x;
                const deltaY = touch.clientY - touchStartRef.current.y;
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
                    if (!isSeeking) setIsSeeking(true);
                    const seekDelta = deltaX / 5; 
                    const newTime = Math.max(0, Math.min(duration, touchStartRef.current.startCurrentTime + seekDelta));
                    setSeekTime(newTime);
                }
            };

            const handleTouchEnd = () => {
                if (isSeeking) {
                    if (videoRef.current) videoRef.current.currentTime = seekTime;
                    setIsSeeking(false);
                } else {
                    const holdTime = Date.now() - touchStartRef.current.time;
                    if (holdTime < 200) handleTap();
                }
            };

            const handleTap = () => {
                if (!video.url) return;
                if (isMuted) { toggleMute(); videoRef.current?.play(); } 
                else { if (videoRef.current?.paused) videoRef.current.play(); else videoRef.current.pause(); }
            };

            const videoStyle = { width: '100%', height: '100%', objectFit: fit, transform: `rotate(${rotation}deg)`, transition: 'transform 0.3s ease', pointerEvents: 'none' };
            const displayTime = isSeeking ? seekTime : currentTime;

            return (
                <div className="relative w-full h-full snap-start bg-black flex-shrink-0 border-b border-gray-800 overflow-hidden">
                    <div className="video-wrapper relative w-full h-full">
                        <video 
                            ref={videoRef} style={videoStyle}
                            loop muted={isMuted}
                            playsInline={true} webkit-playsinline="true" x5-playsinline="true" x5-video-player-type="h5-page"
                            onTimeUpdate={(e) => { if (!isSeeking) { setCurrentTime(e.target.currentTime); setDuration(e.target.duration || 0); } }}
                            onPlay={() => setIsPlaying(true)} onPause={() => setIsPlaying(false)}
                        />
                        <div className="absolute inset-0 z-10" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd} onTouchMove={handleTouchMove} onTouchCancel={handleTouchEnd}></div>
                        
                        {isSeeking && (
                            <div className="absolute inset-0 flex items-center justify-center z-30 pointer-events-none bg-black/40 backdrop-blur-sm">
                                <div className="flex flex-col items-center">
                                    <div className="text-4xl font-bold text-white mb-2 font-mono drop-shadow-lg">
                                        {formatTime(seekTime)} <span className="text-lg text-white/70 ml-2">/ {formatTime(duration)}</span>
                                    </div>
                                    <div className="text-white/80 text-sm font-bold">{seekTime > touchStartRef.current.startCurrentTime ? "⏩ 快进" : "⏪ 后退"}</div>
                                </div>
                            </div>
                        )}
                    </div>

                    {!isPlaying && !isMuted && !isSeeking && video.url && <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20"><Icons.Play size={60} className="text-white/40" /></div>}

                    {/* 顶部进度条 */}
                    <div className="absolute top-0 left-0 right-0 z-50 px-4 pt-16 pb-4 bg-gradient-to-b from-black/80 to-transparent flex gap-3 items-center pointer-events-none">
                        <span className="text-[10px] text-white font-mono drop-shadow-md min-w-[30px] text-right">{formatTime(displayTime)}</span>
                        <div className="flex-1 h-1 bg-white/30 rounded-full overflow-hidden relative"><div className="absolute top-0 left-0 h-full bg-white transition-all duration-100 box-shadow-lg" style={{width: `${(displayTime / (duration || 1)) * 100}%`}}></div></div>
                        <span className="text-[10px] text-white font-mono drop-shadow-md min-w-[30px]">{formatTime(duration)}</span>
                    </div>

                    {/* 右侧边栏 */}
                    <div className="absolute right-4 flex flex-col items-center gap-6 z-20" style={{bottom: '40%'}}>
                        <div onClick={() => setRotation(r => (r + 90) % 360)} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100"><div className="bg-black/30 p-2 rounded-full backdrop-blur-sm border border-white/10"><Icons.Rotate size={24} className="text-white" /></div><span className="text-[10px] text-white shadow-black drop-shadow-md">旋转</span></div>
                        <div onClick={() => setFit(f => f === 'contain' ? 'cover' : 'contain')} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100"><div className="bg-black/30 p-2 rounded-full backdrop-blur-sm border border-white/10"><Icons.Maximize size={24} className="text-white" /></div><span className="text-[10px] text-white shadow-black drop-shadow-md">缩放</span></div>
                        <div onClick={toggleMute} className="flex flex-col items-center gap-1 opacity-80 hover:opacity-100"><div className="bg-black/30 p-2 rounded-full backdrop-blur-sm border border-white/10">{isMuted ? <Icons.VolumeX size={24} className="text-white"/> : <Icons.Volume size={24} className="text-white"/>}</div><span className="text-[10px] text-white shadow-black drop-shadow-md">{isMuted ? '静音' : '音量'}</span></div>
                    </div>

                    {/* 底部信息 */}
                    <div className="absolute bottom-16 left-4 right-4 z-20 text-white pointer-events-none">
                        <div className="font-bold text-lg drop-shadow-md">{video.username}</div>
                        <div className="text-sm opacity-90 drop-shadow-md line-clamp-2 mt-1 leading-relaxed">{video.description}</div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [videos, setVideos] = useState([]);
            const [activeIndex, setActiveIndex] = useState(0); 
            const [isMuted, setIsMuted] = useState(true);
            const [sourceIndex, setSourceIndex] = useState(0); 
            const containerRef = useRef(null);

            // 1. 初始化：加载第一批视频
            useEffect(() => {
                const loadInitial = () => {
                    const firstBatchRaw = ALL_SOURCES.slice(0, INITIAL_LOAD_COUNT);
                    if (firstBatchRaw.length === 0) return;

                    const firstBatch = firstBatchRaw.map((url, i) => ({
                        id: Date.now() + i,
                        url: url.trim(),
                        username: `频道 #${i + 1}`,
                        description: "自动连播中..."
                    }));
                    
                    setVideos(firstBatch);
                    setActiveIndex(0);
                    setSourceIndex(INITIAL_LOAD_COUNT);
                };
                loadInitial();
            }, []);

            // 2. 滚动监听 + 无限加载
            useEffect(() => {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(e => {
                        if (e.isIntersecting) {
                            const id = Number(e.target.getAttribute('data-id'));
                            const index = videos.findIndex(v => v.id === id);
                            
                            if (index !== -1) {
                                setActiveIndex(index); // 更新当前索引，触发虚拟化渲染
                                
                                // 如果滑到了倒数第 2 个，加载下一批
                                if (index >= videos.length - 2) {
                                    loadMore();
                                }
                            }
                        }
                    });
                }, { threshold: 0.6 });

                setTimeout(() => { document.querySelectorAll('.video-slide').forEach(el => observer.observe(el)); }, 500);
                return () => observer.disconnect();
            }, [videos]);

            const loadMore = () => {
                if (sourceIndex >= ALL_SOURCES.length) return; // 到底了

                const nextBatchRaw = ALL_SOURCES.slice(sourceIndex, sourceIndex + BATCH_SIZE);
                if (nextBatchRaw.length === 0) return;

                const nextBatch = nextBatchRaw.map((url, i) => ({
                    id: Date.now() + sourceIndex + i,
                    url: url.trim(),
                    username: `频道 #${sourceIndex + i + 1}`,
                    description: "加载更多..."
                }));

                setVideos(prev => [...prev, ...nextBatch]);
                setSourceIndex(prev => prev + nextBatch.length);
            };

            return (
                <div className="flex justify-center bg-gray-900 h-screen w-full font-sans text-white">
                    <div className="relative w-full h-full bg-black overflow-hidden max-w-md mx-auto shadow-2xl">
                        <div ref={containerRef} className="w-full h-full overflow-y-scroll snap-y snap-mandatory scroll-smooth no-scrollbar ios-scroll">
                            {videos.map((v, index) => {
                                // --- 核心虚拟化逻辑 ---
                                // 只有当前视频和前后各1个视频(共3个)会被渲染成真正的播放器
                                // 其他视频变成轻量级占位符，防止内存溢出
                                const isVisible = Math.abs(index - activeIndex) <= RENDER_WINDOW;
                                
                                return (
                                    <div key={v.id} data-id={v.id} className="video-slide w-full h-full snap-start relative">
                                        <VideoSlide 
                                            video={v} 
                                            isActive={index === activeIndex} 
                                            isVisible={isVisible}
                                            isMuted={isMuted} 
                                            toggleMute={() => setIsMuted(!isMuted)} 
                                        />
                                    </div>
                                );
                            })}
                            {videos.length === 0 && <div className="flex items-center justify-center h-full">载入视频中...</div>}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
